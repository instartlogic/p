PAUL IRISH: All right. Today I want to  share with you some of the good stuff we've  been doing the past year on the DevTools team. And to speak for  the team, we want to enable you and equip you  with the tools to make you a productive developer. None means powerful tooling to  help you understand and improve your application. And we want that experience to  be fun, too, and delightful. So today we're going  to cover a few things. Debugging your  scripts, performance, we're going to look at  auditing for excellence, we're also going to look  at node.js and headless. A lot of good stuff in here. And we're going to  start off with debugging and some console  kind of ergonomics. You know, the console is  part of our core experience. Right? You spend a lot of time  there, and so we enjoy investing in these workflows. So these are a few  of the things that we noticed might need some  sprucing up a little bit. So the console. I'm going to show  you object previews and some new,  improved autocomplete. Object previews, we're going  to show a little video. This is an object, we're  just opening it up, we're exploring it. This is a bunch of  network requests, so it's an array of objects. And to hunt around  and find that one object that I'm really looking  for, it takes a bit of work. Same thing here. I'm just clicking around. And we're just wondering,  maybe we could provide this a little bit more proactively. And so we're switch over  to what it looks like now. Take this object, open it up. Now when you click on Open it. So we get the previews of all  the child objects immediately. So just instantly browse, you  see all the sub-properties, and you're in a good state of  knowing immediately of what's happening inside the data. All right, so that's  object previews, and just another view of that. On the left, you got,  what it was, well, last week, to be honest. But in today's  Chrome Canary, you'll see something a little  bit more like this. So an array of  arrays, and now you get to see exactly  what is in there, without having to  click in all the time. This is good stuff. All right. Yeah. I like it, I like it, it's good. All right. I want to show you some  autocomplete stuff, and I'm going to come  over here to my machine, take a little sip of water. We're going to pop  over to the console. All right. So we're here in the  console, and I'll bring it in on about blank, solid page. Now, you're at the console,  you like to type things, and we want to make sure  that it's very fast for you to get the completions so  that you are just able to do the work that you want to do. I'm going to look at document. And we'll look at  document dot head. And now, I want to  make sure that, I want to look at the child nodes. OK? So I'm going to switch  over to child nodes. Now at this point, I've had  these little autocompletion as I type all these  things in, because we know exactly what document head is. But then we reach this point  where we type in dollar zero, and we've done this  kind of array access. Now when we do  dollar zero, then all of a sudden, the  completions, they used to just completely fail. So I'm just happy to report  that now, you hit period, we're like no  problem, array access. You got your completions, too. Now another one. Let's say that you  have an object. Object looks maybe  like this guy. So the properties have  dashes, and so you might know where I'm going  with this, if we take this and now we run this in the  console, then class is dot-- but I can't, because  there's dashes. Not a problem. Square bracket  notation, no big deal. In square brackets,  we'll just make sure that you have the key  names right here, too. So good stuff. But we can do a  little bit better. You might be more on kind of  the bleeding edge of things than the new side. So let's take this  object here of classes, and we're going  to make it a map. So we'll do map equals  new map, and we're going to use object dot entries. I think this is ES7, even. So object dot entries,  new map, or create a map of the exact same information. Now we do map dot get,  open up the paren, and there are our keys, too. So making sure that  you have all your data right at your fingertips. All right. Now while we're on the  console, sometimes we spend a little bit more  time typing something out than we actually thought. We create not just a one-liner. And we're like OK, well,  there's some work to do. So I'm going to type  out this function. And I call it log. And we'll just say args, and  we'll open up our bracket. At this point you're like, OK,  well, I want to do a function, do I hit Shift, Enter, so  that it doesn't evaluate? I don't want it to error. Don't worry about it anymore. Just hit Enter. We know that you're not done. It's good. We're just going to  give you a new line. We're going to indent. You're in a good place. Now type in console  log, args, log that out and hit Enter again. We know you're not done,  but we close off that brace, and we're like,  yeah, you're good. We'll fix the indentation. You hit Enter once more. Evaluated, all right. That's good. So now we have a nice  multi-line console that's aware of  what's happening, and is not going to  evaluate something that's obviously incorrect. Now this console 2  has some upgrades. Syntax highlighting, this  was not here a year ago. Also other text editor features. For instance, I'm  going to hit Command-D. I can do multiple  selections, and easily just change whatever I need, right  there, inside the console. So, this is some of the  cool stuff in the console. Thank you. And now, I'm going to  switch gears a little bit, and talk about  asynchronous JavaScript. So do you guys write a lot  of asynchronous JavaScript. Hands? Yeah, OK. Do you guys use promises? Yes, promises. All the time. I mean, because what would it  be like if we didn't have that? It's nice. But on the other hand,  debugging promises. Not as much fun really, is it? So I want to talk a little  bit about debugging. I'm going to show it with  a little trio of examples. So we're going to  come back over here. And I like the about blank page. This is good. And I'm going to look  at these snippets. So here we got a snippet here. Zoom out just a tad. So this snippet. We start out with a job. Job runs, we call a  process, in the process, we log out a little  bit, we get some data. We print it out, it's just logs. When we finish up, and I got  a debugger statement here, so that I break. Synchronous execution  flow, we're good. I'm going to run this. This is a snippet, so I  can just click this button, or hit Command,  Enter, and we're good. Well, we do have  a reference error. So we're not perfectly good,  but if I just put that in there, then I think we're good. OK. There was just a necessary  adjustment, that's all. No big deal. I paused here. Synchronous. So we look over  at the call stack. We start off at anonymous. At the instantiation  of this job function. And process gets called,  we go in, we call finish. And we end up there. This should be straightforward. Right? We're good? We're good. All right. Now that we have  that out of the way, we're going to  take it up a notch. So we're going to go from  synchronous to async, but we're going to  use async await. So just some small changes. So now we're going to call job. But we've also introduced  a little sleep function, just delay a few milliseconds. So now inside our process,  we'll log out, but we'll sleep. We'll go fetch a favicon. We'll print out that result,  we'll sleep a little bit more, and we'll finish. Now let's try that out. I'll just run that,  and we pause, and OK. Now the difference here is  that we have the same four call frames in the stack. And they're pointing  at the same location. But in the middle of this, we  have this asynchronous hump. Because going from job over  to this call point and finish, we had an asynchronous  operation. Inside process, all of  these are asynchronous. Sleep, print, and sleep again. So this also works,  it makes sense, but promises are how, I  think, a few more of us these days are doing async work. So I switch over to that. Same basic approach. But with promises this time. Inside job, we do our resolve,  and then we go into here. And inside process, we have a  promise resolve, sleep, fetch, get the result, sleep, finish. So we run that. Call stack, again,  for call frames here. But two asynchronous  hops in there. Now the important  thing here is that we are able to show the  history of why we got here. Admittedly, these are  kind of toy examples. But in the real world, things  get a bit more complex. So this is a slightly  more real-world stack. This is just the immediate  stack of five synchronous call frames, and looks like  something coming from JQuery. There's not a lot of context. But if we have asynchronous  stacks enabled, we have that feature  behind this call stack, then it looks a little bit  more like this, taller stack. But it gives us  much more context. So even down at the  bottom, actually see that this came from an event  handler into submit handler and submit data. So I know, even at the  top, it doesn't really communicate much. I know why this  actually happened. This is increasingly the  default look of stacks. In the browser, we  have many short spurts of synchronous  work held together by asynchronous operations. So like set timeout, request  animation frame, promises. async await, plenty  of other APIs. Not even to mention, reacts,  new core algorithm fiber. This is designed to break  up big chunks of work into small asynchronous  chunks of work. The browser runtime is  all about asynchrony. Just for a look in how  this is in reality, this is a view of all of the  async operations happening over the course of a  quarter of a second. And we're taking all the  asynchronous operations and rendering them  as little arrows. I don't expect you to  get a lot out of this, but just suffice this  to say, it's busy. There's a lot going on. But DevTools is  able to track what is going on from one call  frame, asynchronous hop, over the next. We think it's  imperative for the tools to communicate why you arrived  at a specific call frame. So to pull this off, we've  had to do a lot of work under the hood. So we've instrumented  all of the browser points where asynchrony emerges. The timers and the  rafts and the promises. We worked closely  with the V8 team, and we checked all the dangling  kind of asynchronous execution hooks. And so that we know from  the entirety of the program execution, way back to the  beginning of the page load. In order to pull this off, and  do this efficiently at scale, we needed to do some work. Because we were really driven  to flip the switch on this feature. Making it from something that  was like an opt-in checkbox in the corner to something  that everyone should just get for free, all the time. So there's no reason to  collect expensive snapshots from the VM, replay  execution, or switching out into another tool. So what this really  means is that stopping at any point of your  program execution shows you the  complete asynchronous history of how you got there. It's right there  at your fingertips. But sounds cool. What does this actually enable? I'm going to show you. So I have three new features  I'm going to show to you. Continue to point in-line break  points and step into async. To do that, we're going to  come back to these same demos. All right. The synchronous one. Place a little breakpoint  here on line 8, and we're just going  to start the execution. We pause. I'm going to hit Step  Over, because I just want to work my way down,  result, print the results. At this point, I can  inspect the result. Great. Perfect. This is a common  debugging scenario. But let's bring it over  to the asynchronous world. So here, I'll place  the break point. I'll run pause. Now step over. And I get a step over. And this time, all of  this work is asynchronous, but we're still able to use the  nice convenience of step over. We've made that asynchronous  debugging experience feel just like it  was synchronous. Now, step over works great with  sync code and with O8 Async, But we often do  this a lot of times. Either you're stepping  over, or you'll be like, you know what, I'm here on  this log, here on this line, and I want to jump down to this. I'll just set a  breakpoint right now. I'll play execution. But it happens a lot. So we wanted to make sure  that there was a bit more of a convenient  shortcut for this. So that's continued to point. So now if you're  paused, you hold down the Command key,  or the Control key, and we're going to highlight  in blue a few destinations inside this function that are  available for you to just jump to. So when you click on one  of these destinations, we're going to allow the  execution to go forward. And then we're going to  pause you right there. So I'll do that, I'll  just click on this Print, and we just let the  execution go forward. Now I'm paused here. And of course, I can just  inspect this response. Just a little bit  of a convenience. Cool, thanks. Now promises. I'll pause here. And step over and  step over again. What do you think? I mean, how do you feel about  me stepping over at this point? It's like, yeah,  like what happens? We just jump right  to the end, we are now exiting with a  return value of a promise. None of this work has  even happened yet. And this is like, eh. So we don't have the  power of async await. The nice convenience  of step over. That's not going to work for us. But we want to have this power. So we actually thought  about this, and figured, maybe there's another  way that we can do this. And that led us to  in-line breakpoints. So now, because what  I really want is I really just want  a pause like here. I want to see what  this result is. So I want to pause  here, so I'm just going to put my breakpoint on 14. We're going to highlight  a few areas in that line where we can actually pause. And so that spot  right there, I'll turn that on, and  flip that one off. And now when I go forward,  I start off there, and I continue execution. And now I pause inside  of that function, and now I can inspect  the result like I want. And that works. But to be honest, if you're  using promises as much as I am, you'll be doing  this all the time. So again, we're like, we  could make a little more of a convenience function. We want to be able to pull  this off with a single gesture. So I'll break. And now this time, I'l hold  down Control or Command again. Now there's the  blue destinations, but there's also these  green destinations. The green means  I'm going to step into this asynchronous function. So this time I'm going to step  into this result, print result, and now I am paused inside of  this asynchronous function. And I can inspect the  result just like that. So single gesture or  handling the step into async. All right, guys. So there's a lot of stuff in  the asynchronous debugging. And we're really  excited about it. I know that was a lot. We're going to switch  gears a little bit and talk about performance. Now when we talk to our users,  and we ask questions like, when you guys work  on performance, what sort of panels do you use? What do you guys use? Do you use the profiles panel,  timeline panel, network panel? Obviously, there's a few things. And admittedly, the tools  are a little distributed. But we're talking about  browser performance here. Where the completion  of a JavaScript file downloading immediately  leads to main thread work. And it's critical to  see that connection. And when the JavaScript  finishes executing, the browser takes a moment  to calculate the layout, and sends off pixels  to the screen. This pipeline is  very integrated, so we knew we needed a single,  integrated tool to visualize the entire picture. So that's led us to  the performance panel. All right. So I'm going to show you a  little bit of the performance panel, in action. To do that, come back to my  browser, clear those out. And we're just going to look  at the home page of Nest, just for fun. Bring open the DevTools. Now this is the  performance panel. We have screenshots  enabled, that seems good. And you know what, I  just want to capture a profile of the reload of  the page, just the load. So I'll hit that one button. And what we're just going to  do is capture the entire thing, and we'll stop it automatically  when the page is done loading. All right. So I have some stuff  on the screen, sure. Up in the top is  a little overview. And a filmstrip, and I can  just drag my mouse along and see screenshots of  the page as it loaded. Go from just the very top  bar to a little bit more-- these images, the text. But like I said, we want to  see kind of how this worked. So I'll just zoom in  on, well, everything up to where things  started looking good. And of course, the  page load starts with some network requests. So I'm going to open up network. I'm going to zoom in. This is our HTML, some  JavaScript, some style sheets, and so on. It's the JavaScript  catches my eye right. Nest, web component  bundle, min.js. So the network  connection goes out, we're waiting for  the byte, and then it starts downloading  right here. So it's downloading,  downloading, downloading. What happens when this  file stops downloading? Well, it stops downloading  like right here, the mainframe gets  it right here. And then look at this-- main thread. Evaluate script, web  components bundle. Yeah, that makes sense, OK. So there's a nice connection  between the network and the main thread. So we see that work  there, and we're just going to look to the right. We parse some HTML. Some other things happen. Soon enough, the  browser calculates what it's going to look like. It recalculates style of  the layout, the paint. So I imagine somewhere  around here, it's actually going to ship  these pixels to the screen. So now you can open  up the frames track. And in the frames track,  we have the screenshots of what was happening in  the page just positioned exactly where it  actually happened. So now I can see-- this was when-- we got the top  bar, with the little Nest logo at the top. OK, that's something. I expected more, to be honest. We'll just scroll to  the right a little bit. There we go. So now we got these  images, and then the text. The fact that the text took  a little bit more time, it leads me to an idea. I bet that we're dealing  with web fonts here, and we were waiting for  the web fonts to download. Open up network and  zoom out a little bit. And I bet you that the web  fonts just finished downloading. So I zoom out, and scroll  over here, I spot them here. We have at least the wav  files of white and regular. And these are just completed. And once they completed,  then the browser had a chance to recalculate the  style, which it needs to do, and layout. And then we were able  to ship that frame. So we had this nice  integrated view from the beginnings  of network requests to pixels on the screen. Now, some of you who might  have been using the profiles panel to do JavaScript  development, I just want to orient you with  what we have available here. So I might collapse  again the network. On the main thread,  we're dealing with just over time what is happening. But oftentimes, you're looking  for what consumes the most time, at an aggregate view. So we'll zoom out, and  open up the bottom, and the bottom-up view. The bottom-up view is just  a summary of everything that took time, sorted  by its own self time. So here we can see,  well, there was some JavaScript on the page  that took a little bit of time. The function e. He was a little slow, I guess,  and r, also not so fast. So you know, e and  r, watch yourself. But the other important thing  is that you see this in context, the browser was doing  a bunch of other work. It was compiling scripts,  and laying things out, and recalculating style. And now you get to  understand that maybe e isn't so bad after all. Maybe I need to make  sure that I need to recalculate style  a little bit less, or lay things out less, and  make those take less time. Pro tip-- fewer DOM  elements will help this one. Anyways, that was a good, quick  look at the performance panel, and we hope you dig it. The fastest code  in the browser-- we're talking about  profilers-- the fastest code is the code that never even runs. And better yet, the  fastest code is the code that isn't even downloaded. So we're thinking about  that, and wondering what if we could provide you with a  better view of what is actually being used in the page. And that's led us to  the coverage profiler. I'm Going to give you a short  video of how this works. This is a little, progressive  web app that I made. And we're going to scroll  down to the bottom, open up inside the Drawers  menu, the Coverage panel. At this point, we  can just hit Record and start collecting data. We're actually going  to get instant data, especially from our CSS,  because we know what's applying to the page right now. So here we actually see  all of the selectors, and which selectors have  already been matched the page. The ones that haven't  are in the red. Now select Focus. There's no dropdown  that's been focused. Let's try it. Now we're going to  click in and hit Tab, and that red rule went to green. So instant live updates here,  over in the coverage panel. Now, JavaScript is  also available now. This is the JavaScript file. Half of it is unused. Which isn't great. And we can look down and  there's a get trips function. It's not executed,  feels like it should be. Well, we could just try it out. We're going to  select a schedule. We'll go from San Francisco,  down here to Mountain View, and yeah! Dropped down the 50% unused to  just 10% unused, which is good. You're making good  use of all the bytes. So the coverage profiler gives  you this sort of insight. Armed with this data,  you can go to town. The red, unused bytes,  they are not your friend. They are not your  user's friend, either. Don't send users red bytes. Nobody likes them. Check it out, the  coverage profiler. But then again-- thanks-- then again, sometimes  all the bytes that you're running on a page  are not necessarily yours. They're someone else's. They're third party code. So when you see a network  waterfall of a big site, you're like, a lot  of stuff going on. Like, who is this? And this is a challenge. You should know exactly what  is happening on your site and who it is. So it's all about attribution. We've thought about this, and we  have a new feature to show you. You can try this out  in Chrome Canary now. And it's some third  party attribution. Now, the command palette is a  great place to turn this on. Command-Shift-P, type in  third party, type in badges, flip this on. And once you have  this on, you go over to something like  the network panel. Now, next to the  network requests, we're going to throw a  little badge next to it. So next to the file name,  we'll say something like DC. When you click on DC, you will  just be like, it's DoubleClick. And then you'll see a GA  badge, and you'll be like what? Who? Google Analytics. And we're doing this for a lot  of different third party code. Ads, analytics, tracking,  all sorts of stuff. This is available in other  places too, so in the console, you have logs or  errors, and you're like who is this coming from? Like the M script,  I don't even know, that doesn't tell me much. We're going to tag it there too,  and put the little badges in, you can find out. Also over the timeline, you  can take that bottom-up view, group it by product,  and see OK, looks like these guys are spending a  lot of time on my main thread. It's cool, yeah, I know. All right. So come back here. Yeah, it's good. We got a good amount  of data in here. We're recognizing over 1,400  different projects, products, and that means  over 5,000 domains, that we're keeping  track of and showing. The data's just built in there,  but we have a little link report mismatch. If anything looks fishy to  you, click it, report it to us. We want to make sure that the  data is super useful to you, and as accurate as we can be. All right. Brings us to authoring. We've covered debugging,  performance insights, but there's some other key  actions in your workflow. And we've added  some features there. I think you're going to  like them, some good stuff. This one, cookie editing. You've been able to view  cookies for a while, not been able to edit cookies. I know, I know, I know. You're excited about this one. Yes, a long time coming. We have cookie editing,  we're good now. Next one is a good one. Change tracking. So often you get into  this case, you're editing the CSS, just  tweaking something, you make a bunch of changes. At this point, you've  got it to where you want it to look like, you've  lost track of all the changes that you've made. So down in the drawer, you  can open up the changes view, and we're going to summarize. We're going to give you a  [? diff ?] of all the changes that you've made, file by file. This is an experiment,  as of today, but we'll be turning it on  in Canary by default Monday? Monday. Let's do that. OK, good. All right. Screenshots, yeah. All right. Check this out. So we're looking at  the Google store. You want to take a  screenshot of the page. Now we're going to use  that command palette. Command-Shift-P, type  in screenshot, and we can just capture the screenshot. Captures it at ping. We can open it up, boom, easy. All right. This is good. It's been there for a little  bit, but I can do better, I can do better. We're going to open  up the device menu, and we can do the  same thing there. But what I like to do, is I like  to turn on the device frame, get that nice art around it.. Then you capture screenshot,  and you got that good look. Looks good in presentations. Puppies and dogs are  really impressed with that. Show them, they'll love it. And then there's one more  that I like even more. The full-size screen shot. Where you get the full  page, capture it, and now single ping, full resolution. I'm right there with you,  I'm right there with you. All right, there's one more. I had to sneak this in. I like to call it  breakpoint resolving. You know how sometimes you  put a breakpoint on a page, and then you go  change it around. And then, all of the  sudden, it's not on the line that you meant for it to be on. That's kind of a pain. So I'll do that here. I'll place this breakpoint-- put the breakpoint  on construct select. Now I'm going in my editor,  I'm moving things around, adding a log. I'm going to come back. It's there, but when I refresh,  it's in the first run function. Different thing, it's  not where I left it. Like, eh. All right. Now you'll see this  in Canary, beta. Use refresh. We keep the position. We track where that was. And even if you change  things around a little bit, we're going to make sure  that the breakpoint stays on the same line. All right. It's good. It's not going to work all  the time if you completely change things. We're going to lose track. But we're going to do our best. Now I wanted to share with  you one of my favorite parts. Here, that's good. About the past year and  a half, personally, I've been working on the  Lighthouse Project. And Lighthouse is great. It gives you a lot of  insight into what's happening and sort of improvements  that you can make. It's available as a Chrome  extension, command line app, a node module, access  it in a variety of ways. But we always knew  that there was value in having it  more deeply integrated into the developmental workflow. So I'm going to  show you what this looks like with the  DevTools integration. So we'll look at Chrome  experiments, as an example. Pop open the DevTools. And we're going to go  over to the audits panel. Audits panel has been  refreshed a little bit. We'll go down,  we'll run an audit. We're just going to do the  full audit of everything. At this point, we're  emulating a Nexus 5x, or throttling  network, we're even throttling CPU to slow it down  a little bit more like a phone. And we're looking  at a lot of things. We're looking at  the load performance and capturing a bunch  of different metrics. Also looking at things like  accessibility, how much of a progressive web app it is. All that. Then we get the report  right here in the DevTools. And so a few things going on  with this site, progressive web app side, not so good for them. But you know they're  HPS, some good stuff. In the performance  section, a filmstrip and some of the  high quality metrics you might have heard about. First meaningful paint,  first interactive, and how those line up  against the screenshots. And then other things  like image optimization. We're giving you an idea  of how much value you're going to get out of all  those recommendations. So you don't have to guess  and be like, it really wasn't that impactful. Now I'll show one more  thing, while I'm at it. Google, I just ran this  on the Google Home Page. And the accessibility results  were kind of interesting to me. So I opened that up, and because  we're in DevTools, now when you hover over  this node results, we're just going to  highlight it up there. You can click through and  just start inspecting it in the elements panel. So do that again  with color contrast . So now a few things, looks  like in the footer, that don't hit the color  contrast mark, and we see them highlighted. And we can see immediately  the actual elements that we're talking about. So this nice integration between  the deep insights of Lighthouse and the runtime of DevTools  together brings a lot of power. I've saved a developer  favorite until now. Headless browsers,  they enable you to create automated  tools that can run in a variety of  different settings. And people do a lot  of things with this. Text extraction, screenshots,  and performance testing, security testing, unit testing. I mean, everyone  here, raise your hand if you're using a headless  browser, of some sort, in your workflow. Yes, of course, a lot of things. And we've seen this happening. And for the longest time,  us on the Chrome team, we've been wanting to provide a  contribution to that scenario, to those workflows. And so today we're happy  to officially announce the availability  of Chrome Headless. Chrome Headless works great  on all OS, Linux, and Mac, and Windows. It's working great  in all these places. Windows, Chrome 60,  a little bit newer. The other ones are  in great shape. And so this enables quite a bit. It has a lot to come. Selenium support, for  instance, is right on the way. We're really excited about this. Right now, things are  a little bit low-level. There'll be higher-level  APIs coming soon. There's a big, flourishing  developer community coming around Chromium  Headless right now, and its primary API, which  is the DevTool's protocol. So I encourage you, if  you're curious about this, check it out. There's a great blog  post from Eric Bidelman about Chrome Headless. And it's going to  get you started with how things work and  all sorts of tools available right now. All right. Last thing. Node.js. So who here develops with node? Yeah, yeah, yeah, me too. There is a lot going on. Last year, a year ago  here, we announced that node.js could be debugged  and profiled with DevTools. Well we announced a pull  request that enabled it. The pull request  is submitted, we're like, we'll announce that,  because that's where we got. But soon enough,  the pull request got merged into  node.js, and it shipped. And so now we're in a great  place, because a lot of us developers, we spend time both  in the browser and in node. And we want to make  sure that the experience in debugging node is good. So I'm going to show you some  improvements to the workflow that we have made,  and to contrast it to what debugging node  was like two years ago. It's good, it's so good. All right. I'll show you a little  bit of stuff here. Now I'm actually  just going to be-- this is how I debug Lighthouse  when I'm working on it. And I'll bring back  open this browser. This one, yeah, great. Now I'll do something like this. This command. Node. And I'm going to be  running this script. But anyways, the important  thing is, inspect break. This says that I'm going  to start inspection, and I want to put a breakpoint  on the very beginning. Otherwise, I'm just  running Lighthouse. So first thing, I hit Enter. This URL pops out. Now if you've done  this before, you've seen this URL and  you're like, OK, well, I guess I'll copy and paste it. And you can, you certainly can. But there are better ways. So one better way is we  can type in about inspect, and we see this panel. And the best one here that  I recommend you clicking, instead of this  shiny-looking guy, is the dedicated  DevTools for node. Now this window is going to  be dedicated to just node, and so you can see  immediately, we broke on the program execution. And I, again, have all  the power that I need. I can continue, step  in, and just go crazy. So that's good, but we can  do a little bit better. Now this time I'm  thinking it would be good if I didn't have to remember  that URL about inspect every single time,  and this functionality was available to me, and a bit  more in an immediate place, where I spent a lot of my time. So now I'm going to  open up DevTools. And when I run this  command again-- I hope you spotted  this, but right up next to Inspect Element  icon, there's a new one. Little green node icon. That snuck in  there, right there. We detected that there  is a de-bug with node. And we're like you know  what, if you want to de-bug that, we got you, right here. So you get to come  over and click that. We're going to pop open  that same dedicated DevTools for node window. The cool thing about  this dedicated window-- I love this, as you know. This works and I'm debugging,  and I do what I need, and I'm like OK, I found a bug. And so now I'm going  to need to fix a bug. And I'm changing things. I need to run it again,  and so I'll run it again. But because we have  that dedicated window, it's like, hey, I'm  right here, I got you, I'll pop right back open. So it's always there  and connecting, so even if you have  to restart node, you have that one single window. And that's going to take  care of you the entire time. All right. So we're going to  have to stop there. You guy have made it. We've covered a lot. We've covered a bunch of  new features in DevTools. From that great, new experience  with object previews, the autocomplete in the  console, all the asynchronous debugging goodies,  performance panel, coverage, third party attribution,  Chrome Headless, node. All sorts of good stuff. If you like this kind of a  thing, follow us on Twitter. Great docs, updated regularly. And if ever you have bugs,  we definitely want to know. If you have feature requests,  we also definitely want to know. Any feedback, just tell us about  your workflow, and the sorts of things that work for you. New.crbug.com is where  you can find us, reach us, throw us a message. We'd love to hear from you. That's it for me. Thank you guys, very much. Appreciate it. [CLAPPING] [MUSIC PLAYING] "